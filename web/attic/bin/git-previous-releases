#!/bin/bash
##
##  Show a list of release versions, descriptions, and dates, tab-delimited,
##  based on Git tags
##
# shellcheck disable=SC1117,SC2034
set -uo pipefail

ME=$(basename "${BASH_SOURCE[0]}")
# force default (English) locale for month names
LC_ALL=C
LINUX=$([[ $(uname -s) == Linux ]] && echo 1)

if [[ -t 1 ]]; then
    BLD=$(tput bold)
    RST=$(tput sgr0)
else
    BLD=; RST=;
fi

# TODO
#DATEFMT='%e %B %Y'  # e.g., 6 July 2020

USAGE="
$BLD$ME$RST - list release versions reverse-cronologically based on Git tags

  usage:
    $ME [-h|--help] [-p|--prior-only] [-s|--strip-prefix PREFIX]

  where:
    -h, --help               shows this help
    -p, --prior-only         skips the most current, shows prior releases only
    -x, --cut-prefix PREFIX  removes PREFIX from the beginning of all tags
    -s, --since VER          shows releases since VER (after cutting off PREFIX)
    -r, --reverse            shows releases in reverse-chronological order
    -d, --delimiter DELIM    uses DELIM as field separator (default: tab)"

# TODO
#    -f, --date-format FMT    uses FMT for date output, e.g. '%Y-%m-%d'
#                             see date(1) for details (default: '$DATEFMT')

##
##  functions
##

bail() {
    echo -e "\n${BLD}ERROR$RST: $*\n" >&2; exit 1
}


# pipe through filter $2 if variable named by $1 is non-zero/non-null
filter_if() {
    local cond=$1
    shift
    if [[ -z "$cond" ]]; then cat; else "$@"; fi
}

# macOS/BSD doesn't have 'tac' but 'tail -r' does the same thing
filter_reverse() {
    if (( LINUX )); then tac; else tail -r; fi
}

# macOS/BSD 'head' doesn't understand 'head -n-1' (all but last)
filter_all_but_last() {
    if (( LINUX )); then head -n-1; else tac | tail -n+2 | tac; fi
}

filter_strip_prefix() {
    local prefix=${1:?missing tag prefix to strip}
    sed "s/^$prefix//"
}

# print lines if column 1's maj.minor release is >= $1, using tab as field sep
filter_since() {
    local since=${1:?missing version in X.Y format}

    # shellcheck disable=SC1004
    awk -v since="$since" '
        BEGIN { FS = "\t"; OFS = "\t" }
        {
            ver = $1
            # strip *any* non-numeric prefix/suffix before comparison
            sub(/[^0-9.]*$/, "", ver)
            sub(/^[^0-9.]*/, "", ver)
            split(ver, parts, ".")
            ver = parts[1] "." parts[2]

            if (ver !~ /^[0-9]+\.[0-9]+$/) {
                print "Could not parse \"" $1 "\" (got \"" ver "\")." > "/dev/null"
                exit 1
            }
            if (ver >= since) print $1, $2
        }'
} # filter_since

filter_resep() {
    fromsep=${1:?missing \"from\" separator}
    tosep=${2:?missing \"to\" separator}

    if [[ $fromsep != "$tosep" ]]; then
        awk -v FS="$fromsep" -v OFS="$tosep" '{ print $1, $2 }'
    fi
}

# TODO: output tag/ commit date as a third column
# '-r' is how macOS/BSD date takes epoch seconds as the input date
# '%e' is day of month, space-padded, and I don't want that space
#date_from_epoch() {
#    date -r "$1" +"$2" | sed 's/^ //'
#}
# GNU date's '-r' means something else
#date_from_epoch() {
#    date --date="@$1" +"$2" | sed 's/^ //'
#}

(( ${TRACE:-} )) && set -x

prior=
prefix=
since=
reverse=
delim=

# TODO
#fmt=$DATEFMT

while (( $# )); do
    case $1 in
        -h|-help|--help)
            # NB: if run as 'git previous-releases --help', Git will bogart the
            # '--help' option and try to show 'git-previous-releases' man page
            echo -e "$USAGE\n"
            exit
            ;;
        -p|--prior*)
            prior=1
            ;;
        -x*|--cut*)
            if [[ $1 =~ ^-x(.+) ]]; then
                prefix=${BASH_REMATCH[1]}
            elif [[ $1 =~ ^--cut(.*)=(.+) ]]; then
                prefix=${BASH_REMATCH[2]}
            else
                shift
                if (( $# == 0 )); then
                    bail "Insufficient arguments for '-x' / '--cut-prefix' option."
                fi
                prefix=$1
            fi
            if [[ $1 =~ [^-_[:alpha:]] ]]; then
                 bail "Invalid prefix for '--cut-prefix'; expected alphabetic, '-', '_' only."
            fi
            ;;
        -s*|--since*)
            if [[ $1 =~ ^--?s(ince=)?(.+) ]]; then
                since=${BASH_REMATCH[1]}
            else
                shift
                if (( $# == 0 )); then
                    bail "Insufficient arguments for '-s' / '--since' option."
                fi
                since=$1
            fi
            if [[ ! $since =~ ^[0-9]+\.[0-9]+$ ]]; then
                 bail "Invalid version for '--since'; expected 'major.minor'"\
                      "(numeric digits only)."
            fi
            ;;
        -r|--rev*)
            reverse=1
            ;;

        # TODO
        #-f*|--format*|--date-format*)
        #    if [[ $1 =~ ^-f(.*) ]]; then
        #        format=${BASH_REMATCH[1]}
        #    elif [[ $1 =~ ^--(date-)?format=(.*) ]]; then
        #        format=${BASH_REMATCH[2]}
        #    else
        #        shift
        #        if [[ ! $1 =~ % ]]; then
        #             bail "Invalid date format; see date(1) man page."
        #        fi
        #        format=$1
        #    fi
        #    ;;

        -d*|--delim*)
            if [[ $1 =~ ^-d(.+) ]]; then
                delim=${BASH_REMATCH[1]}
            elif [[ $1 =~ ^--delim(.*)=(.+) ]]; then
                delim=${BASH_REMATCH[2]}
            else
                shift
                if (( $# == 0 )); then
                    echo "Insufficient arguments for '-d' / '--delimiter' option."
                fi
                delim=$1
            fi
            ;;
        *)
            echo "$USAGE" >&2
            bail "Invalid option(s)."
            ;;
    esac
    shift
done  # while we have input arguments


# the output of git tag is cronological (0.1.0 -> 10.0.0), and the
# '--prior-only' option means drop the most recent tag, e.g., "10.0.0"
git tag -n \
  | filter_resep "  " $'\t' \
  | filter_if "$prior" filter_all_but_last \
  | filter_if "$since" filter_since "$since" \
  | filter_if "$prefix" filter_strip_prefix "$prefix" \
  | filter_if "$delim" filter_resep $'\t' "$delim" \
  | filter_if "$reverse" filter_reverse
